# 西联平台 — 数据库迁移统一治理报告

## 一、审计概要

对项目中三套数据库迁移脚本（`drizzle/`、`migrations/`、`docker/mysql/migrations/`）以及 Docker 初始化脚本（`docker/mysql/init/`）进行了全面审计。

### 1.1 四个迁移来源

| 来源 | 路径 | 表数量 | 列名风格 | 角色 |
|------|------|--------|---------|------|
| **Drizzle Schema** | `drizzle/schema.ts` | **121** | snake_case | TypeScript 权威定义（ORM 层） |
| **Drizzle 迁移** | `drizzle/0000_strong_gravity.sql` | 30 | **camelCase** | Drizzle Kit 自动生成（已过时） |
| **Docker 初始化** | `docker/mysql/init/01-schema.sql` | 54 | snake_case | Docker 首次部署 |
| **Docker 升级** | `docker/mysql/init/03-schema-upgrade-v2.sql` | 6 (新增) | snake_case | Docker 增量升级 |
| **Docker 补丁** | `docker/mysql/migrations/003-fix.sql` | 0 (ALTER) | snake_case | 字段重命名修复 |
| **Docker 全量对齐** | `docker/mysql/migrations/004-full-schema.sql` | 32 | snake_case | 全量重建（有严重 bug） |
| **独立算法迁移** | `migrations/create_algorithm_tables.sql` | 5 | snake_case | 手动算法表 |
| **运行时 ensureTable** | `server/services/access-layer.service.ts` | 3 | snake_case | 接入层动态建表 |
| **ClickHouse DDL** | `server/lib/storage/clickhouse.storage.ts` | 4 | snake_case | ClickHouse 时序表 |

### 1.2 核心数据

| 指标 | 数值 |
|------|------|
| schema.ts 定义的表 | **121** |
| 所有 SQL 覆盖的表 | **65**（去重） |
| **缺失迁移的表** | **56** |
| 废弃表（已 DROP） | 6 |
| 运行时动态建表 | 3 (MySQL) + 4 (ClickHouse) |

---

## 二、发现的问题

### 问题 P1：schema.ts 与 SQL 迁移严重脱节（56 张表无迁移）

`drizzle/schema.ts` 定义了 121 张表，但所有 SQL 迁移加起来只覆盖 65 张。**56 张表只存在于 TypeScript 定义中，从未生成过 SQL 迁移**。这意味着：

- 新环境部署时，这 56 张表不会被创建
- 运行时 ORM 查询会因为表不存在而报错
- 开发者无法判断哪些表是"真实存在的"

**缺失的 56 张表按领域分类**：

| 领域 | 缺失表 |
|------|--------|
| **告警/事件** | alert_event_log, alert_rules |
| **算法** | anomaly_models |
| **审计/日志** | async_task_log, audit_logs, audit_logs_sensitive, config_change_logs |
| **接入层** | data_bindings, data_connectors, data_endpoints |
| **数据治理** | data_clean_results, data_export_tasks, data_governance_jobs, data_lineage |
| **数据采集** | data_collection_metrics, data_collection_tasks |
| **数据资产** | data_assets, data_lifecycle_policies |
| **设备管理** | device_daily_summary, device_firmware_versions, device_maintenance_logs, device_protocol_config, device_rule_versions, device_status_log |
| **诊断** | diagnosis_results |
| **边缘网关** | edge_gateway_config, edge_gateways |
| **知识库** | kb_chunks, kb_conversation_messages, kb_conversations, kb_embeddings, kb_qa_pairs |
| **知识图谱** | kg_diagnosis_paths, kg_diagnosis_runs, kg_evolution_log, kg_graph_edges, kg_graph_nodes, kg_graphs |
| **消息队列** | message_queue_log, message_routing_config |
| **MinIO** | minio_file_metadata, minio_upload_logs |
| **模型管理** | model_deployments, model_inference_logs, model_registry, model_training_jobs |
| **流水线** | pipeline_node_metrics, pipeline_runs, pipelines |
| **插件** | plugin_events, plugin_instances, plugin_registry |
| **实时数据** | realtime_data_latest |
| **回滚** | rollback_triggers |
| **调度** | scheduled_tasks |
| **传感器** | sensor_mp_mapping |
| **系统配置** | system_configs |
| **拓扑** | topo_alerts, topo_layers, topo_snapshots |
| **振动** | vibration_1hour_agg |

### 问题 P2：Drizzle 迁移列名风格错误（camelCase vs snake_case）

`drizzle/0000_strong_gravity.sql` 是 Drizzle Kit 早期自动生成的，使用 **camelCase** 列名（如 `detectionId`、`sensorId`、`algorithmType`）。但 `schema.ts` 已经修正为 snake_case 映射（如 `varchar("detection_id")`）。

这导致：
- 如果用 `drizzle-orm/migrator` 运行 `0000_strong_gravity.sql`，会创建 camelCase 列名的表
- 但 ORM 运行时查询的是 snake_case 列名
- **列名不匹配，查询全部失败**

### 问题 P3：Drizzle Journal 损坏

`drizzle/meta/_journal.json` 只注册了 1 个迁移（`0000_strong_gravity`），但 `drizzle/` 目录下有 9 个 SQL 文件（`0000_complex_exodus`、`0001-0007`）。这些未注册的文件是历史残留，不会被 `drizzle migrate` 执行。

### 问题 P4：docker/mysql/migrations/004 有严重 bug

`004-full-schema-alignment.sql` 有 6271 行，包含 **20 个重复的 PART D 段**，同一张表被 CREATE 了 20 次。虽然使用了 `IF NOT EXISTS` 不会报错，但这是脚本生成错误，文件体积膨胀 20 倍。

### 问题 P5：三套迁移互相不知道对方的存在

| 迁移系统 | 执行时机 | 追踪机制 |
|----------|---------|---------|
| `docker/mysql/init/` | Docker 首次启动 | MySQL `docker-entrypoint-initdb.d` 自动执行 |
| `docker/mysql/migrations/` | 手动执行 | 无追踪（靠文件名序号） |
| `drizzle/` | `drizzle migrate` 命令 | `_journal.json`（已损坏） |
| `migrations/` | 手动执行 | 无追踪 |
| `ensureTable` | 服务启动时 | `CREATE IF NOT EXISTS` |

没有统一的版本追踪，无法判断当前数据库处于哪个迁移版本。

### 问题 P6：接入层 3 张表绕过迁移系统

`data_connectors`、`data_endpoints`、`data_bindings` 在 `access-layer.service.ts` 中通过 `ensureAccessLayerTables()` 动态创建，但也在 `schema.ts` 中定义了。这种"双重定义"容易导致字段不一致。

---

## 三、统一治理方案

### 3.1 确立单一权威源（Single Source of Truth）

> **`drizzle/schema.ts` 是唯一权威的数据库 Schema 定义。所有 SQL 迁移必须从它生成。**

### 3.2 治理步骤

#### 步骤 1：重新生成 Drizzle 迁移（替代所有历史迁移）

```bash
# 1. 清理旧的迁移文件
rm -rf drizzle/0000_*.sql drizzle/0001_*.sql drizzle/meta/

# 2. 重新生成（会基于 schema.ts 生成完整的 CREATE TABLE）
npx drizzle-kit generate
```

这会生成一个新的 `0000_xxx.sql`，包含 schema.ts 中全部 121 张表，列名为 snake_case。

#### 步骤 2：重建 Docker 初始化脚本

将 `docker/mysql/init/01-schema.sql` 替换为 Drizzle 生成的全量 SQL（121 张表）。保留 `02-seed-data.sql`。删除 `03-schema-upgrade-v2.sql`（已合并到全量中）。

#### 步骤 3：清理废弃文件

| 操作 | 文件 |
|------|------|
| **删除** | `drizzle/0000_complex_exodus.sql`（未注册的残留） |
| **删除** | `drizzle/0001-0007_*.sql`（未注册的增量残留） |
| **删除** | `docker/mysql/migrations/004-full-schema-alignment.sql`（有 20x 重复 bug） |
| **归档** | `docker/mysql/migrations/003-fix-schema-consistency.sql` → `docker/mysql/migrations/archive/` |
| **归档** | `migrations/create_algorithm_tables.sql` → `docker/mysql/migrations/archive/` |

#### 步骤 4：消除 ensureTable 冗余

将 `access-layer.service.ts` 中的 `ensureAccessLayerTables()` 改为仅在开发环境执行，生产环境依赖 Drizzle 迁移。

#### 步骤 5：建立迁移工作流规范

```
┌─────────────────────────────────────────────────────┐
│  修改 drizzle/schema.ts                              │
│         ↓                                            │
│  npx drizzle-kit generate                            │
│         ↓                                            │
│  检查生成的 SQL 是否正确                               │
│         ↓                                            │
│  npx drizzle-kit push (开发环境)                      │
│  或 drizzle migrate (生产环境)                        │
│         ↓                                            │
│  同步更新 docker/mysql/init/01-schema.sql             │
│  (从 drizzle 生成的 SQL 复制)                         │
└─────────────────────────────────────────────────────┘
```

### 3.3 目录结构（治理后）

```
drizzle/
  schema.ts           ← 唯一权威 Schema 定义（121 表）
  relations.ts        ← 表关系定义
  meta/
    _journal.json     ← 迁移历史（重建后干净的）
  0000_initial.sql    ← 全量初始迁移（121 表，snake_case）

docker/mysql/
  init/
    01-schema.sql     ← Docker 初始化（从 drizzle 同步，121 表）
    02-seed-data.sql  ← 种子数据（保留）
  migrations/
    archive/          ← 历史迁移归档（仅供参考）
      003-fix-schema-consistency.sql
      004-full-schema-alignment.sql
      create_algorithm_tables.sql

migrations/           ← 删除此目录（已合并到 drizzle）
```

---

## 四、执行计划

| 序号 | 操作 | 风险 | 说明 |
|------|------|------|------|
| 1 | 清理 drizzle/ 历史残留文件 | 低 | 这些文件未被 journal 注册，不影响任何环境 |
| 2 | 重新生成 drizzle 迁移 | 中 | 需要 DATABASE_URL，在 sandbox 中无法执行，改为手动生成 |
| 3 | 用 schema.ts 生成全量 01-schema.sql | 低 | Python 脚本从 schema.ts 提取 |
| 4 | 归档废弃迁移文件 | 低 | 移到 archive/ 目录 |
| 5 | 修改 ensureTable 为开发环境限定 | 低 | 加 `if (process.env.NODE_ENV !== 'production')` |
| 6 | 添加 MIGRATION_GUIDE.md | 无 | 文档化迁移工作流 |

---

## 五、风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| 现有数据库已有 camelCase 列名 | 查询失败 | 需要执行 003-fix 中的 ALTER 来重命名 |
| 重新生成迁移后 journal 重置 | 已有环境无法增量迁移 | 使用 `drizzle-kit push` 直接同步 |
| 删除 004 后已执行过的环境 | 无影响 | 004 是幂等的（IF NOT EXISTS） |

---

## 六、总结

当前迁移管理的核心问题是 **"多源头、无追踪、不一致"**：

1. **schema.ts 定义了 121 张表，但 SQL 只覆盖 65 张** — 56 张表永远不会被创建
2. **Drizzle 迁移使用 camelCase，但 schema.ts 和 Docker 迁移使用 snake_case** — 列名冲突
3. **三套迁移互相独立，无统一版本追踪** — 无法判断数据库当前状态
4. **004 迁移有 20x 重复 bug** — 脚本质量问题

治理方案的核心是 **确立 `drizzle/schema.ts` 为唯一权威源**，所有 SQL 从它生成，消除多源头混乱。
